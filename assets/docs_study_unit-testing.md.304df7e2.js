import{_ as e,o as t,c as i,a as l}from"./app.3a9b9990.js";const b=JSON.parse('{"title":"前端单元测试","description":"","frontmatter":{},"headers":[{"level":2,"title":"单侧的定义","slug":"单侧的定义","link":"#单侧的定义","children":[]},{"level":2,"title":"单测完善程度的衡量","slug":"单测完善程度的衡量","link":"#单测完善程度的衡量","children":[]},{"level":2,"title":"单测的价值与意义","slug":"单测的价值与意义","link":"#单测的价值与意义","children":[]},{"level":2,"title":"单侧的编写原则","slug":"单侧的编写原则","link":"#单侧的编写原则","children":[{"level":3,"title":"具体实现代码之前","slug":"具体实现代码之前","link":"#具体实现代码之前","children":[]},{"level":3,"title":"与具体实现代码同步进行","slug":"与具体实现代码同步进行","link":"#与具体实现代码同步进行","children":[]},{"level":3,"title":"编写完功能代码后","slug":"编写完功能代码后","link":"#编写完功能代码后","children":[]}]},{"level":2,"title":"测试工具","slug":"测试工具","link":"#测试工具","children":[]}],"relativePath":"docs/study/unit-testing.md","lastUpdated":1706771416000}'),a={name:"docs/study/unit-testing.md"},c=l('<h1 id="前端单元测试" tabindex="-1">前端单元测试 <a class="header-anchor" href="#前端单元测试" aria-hidden="true">#</a></h1><p>近几年，前端发展越来越迅猛，各类框架层出不穷，前端实现的业务逻辑也越来越复杂，前端单元测试也越来越受重视，包括百度在内的一些大厂在面试中也会问到单元测试相关的题目。</p><h2 id="单侧的定义" tabindex="-1">单侧的定义 <a class="header-anchor" href="#单侧的定义" aria-hidden="true">#</a></h2><blockquote><p>在计算机编程中，单元测试（Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p></blockquote><blockquote><p>程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p></blockquote><p>定义里面指出，单元测试针对的是程序的最小单元，因此我们应该针对最小单元来写单测。</p><h2 id="单测完善程度的衡量" tabindex="-1">单测完善程度的衡量 <a class="header-anchor" href="#单测完善程度的衡量" aria-hidden="true">#</a></h2><p>单测完善程度的衡量用覆盖率来衡量，关于测试覆盖率，我们大致了解下以下几个常见的计算维度：</p><ul><li>行覆盖率：可执行语句执行的比例</li><li>函数覆盖率：函数被调用的比例</li><li>分支覆盖率：判断语句分支被执行的比例</li></ul><p>来看下面这个例子：</p><p><img src="https://pic3.zhimg.com/80/v2-19de62784f67a4c442bb3081497194ea_1440w.jpg" alt=""></p><p>对于测试用例 foo(4)，分支覆盖率只有50%，原因是 foo(4) 只测试了if 为 true 的情况，没有测试到 if 为 false 的情况。</p><p>如果想要分支覆盖率达到100%，还应该测试 foo(5)。</p><h2 id="单测的价值与意义" tabindex="-1">单测的价值与意义 <a class="header-anchor" href="#单测的价值与意义" aria-hidden="true">#</a></h2><ul><li><strong>能力建设</strong>：一个具备开发经验的开发人员，基本上都会编写单元测试。即便不会，可以通过培训来快速达成。从学习曲线上看，单元测试很容易上手。</li><li><strong>提升效率</strong>：能够通过 mock 数据，及早发现问题，而越早发现Bug，造成的浪费就会越小。</li><li><strong>追求卓越</strong>：单元测试可以充当一个设计工具，它有助于开发人员去思考代码结构的设计，让代码更加有利于测试。</li><li><strong>测试更全面</strong>：能够覆盖 QA 测试覆盖不到的情况，比如各种 if 分支、异常处理。</li><li><strong>更有信心</strong>：升级公共 API 时，如果依赖这个 API 的所有代码单测都能通过，那我们对这次代码升级是更有信心的。</li></ul><h2 id="单侧的编写原则" tabindex="-1">单侧的编写原则 <a class="header-anchor" href="#单侧的编写原则" aria-hidden="true">#</a></h2><blockquote><p>单测的原则</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-9eb11cfc3908c4915d195106cbac8eb2_1440w.jpg" alt=""></p><blockquote><p>单测需要测什么</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-1017705bf42c3667c4ceb4f4b2d5f56a_1440w.jpg" alt=""></p><blockquote><p>写单侧的时机</p></blockquote><p>写单测的时机主要有以下三种</p><h3 id="具体实现代码之前" tabindex="-1">具体实现代码之前 <a class="header-anchor" href="#具体实现代码之前" aria-hidden="true">#</a></h3><p>即测试驱动开发（TDD）：编写某个功能的代码之前先编写测试代码，然后编写使测试通过的功能代码，重复这个过程，通过测试来推动整个开发的进行。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>UT 能够更好的实践我们的代码设计。对于某些复杂度较高的接口（甚至是一些私有方法），建议使用 TDD 进行开发。</p></div><h3 id="与具体实现代码同步进行" tabindex="-1">与具体实现代码同步进行 <a class="header-anchor" href="#与具体实现代码同步进行" aria-hidden="true">#</a></h3><p>先写少量功能代码，紧接着写单元测试（重复这两个过程，直到完成功能代码开发）。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>每个单测比较简单易懂，可读性可维护性都比较好（重构时单测的改动不大）。</p></div><h3 id="编写完功能代码后" tabindex="-1">编写完功能代码后 <a class="header-anchor" href="#编写完功能代码后" aria-hidden="true">#</a></h3><p>这种单元测试“粒度”会比较粗。对同样的功能代码，采取前两种方案的结果可能是用10个“小”的单测来覆盖，而这种方案写的单测，往往是用1个“大”的单测来覆盖。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>逻辑就比较复杂，因为它要测的东西很多，可读性可维护性可能会比较差。</p></div><h2 id="测试工具" tabindex="-1">测试工具 <a class="header-anchor" href="#测试工具" aria-hidden="true">#</a></h2><ul><li><strong>Jest</strong> 是目前最流行的框架之一，是Facebook团队构建和维护的JavaScript测试框架，基于 Jasmine，至今已经做了大量修改添加了很多特性。</li><li><strong>Vitest</strong> 的主要优势之一是它与 Vite 的统一配置、并且对 jest 友好。vitest会读取您的根目录<code>vite.config.ts</code>以匹配插件并设置为您的 <code>Vite</code> 应用程序。</li></ul>',33),s=[c];function o(r,n,d,h,p,u){return t(),i("div",null,s)}const f=e(a,[["render",o]]);export{b as __pageData,f as default};
